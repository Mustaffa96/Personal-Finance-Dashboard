'use client';

// Add priority loading hint
export const runtime = 'edge';
export const preferredRegion = 'auto';

import { useQuery } from '@tanstack/react-query';
import { TransactionType } from '@/domain/entities/Transaction';
import { useState, Suspense, useEffect, memo } from 'react';
import { ApiTransactionRepository } from '../../../adapters/repositories/TransactionRepository';
import { ApiCategoryRepository } from '../../../adapters/repositories/CategoryRepository';
import { TooltipItem } from 'chart.js';

// Import Chart.js components dynamically with improved loading placeholder
import dynamic from 'next/dynamic';

// Memoized loading placeholder with fixed dimensions to prevent layout shift
const ChartPlaceholder = memo(() => (
  <div className="animate-pulse bg-blueGray-100 rounded flex items-center justify-center h-[350px] w-full" style={{contain: 'size layout', aspectRatio: '1/1'}}>
    <div className="text-sm text-blueGray-500">Loading chart...</div>
  </div>
));
ChartPlaceholder.displayName = 'ChartPlaceholder';

// Skeleton loader component for the chart with fixed dimensions to prevent layout shift
const ChartSkeleton = () => (
  <div className="animate-pulse flex flex-col items-center justify-center h-[350px] w-full" style={{contain: 'size layout', aspectRatio: '1/1'}}>
    <div className="rounded-full bg-gray-200" style={{ height: '250px', width: '250px', contain: 'size' }}></div>
    <div className="flex flex-wrap justify-center mt-4 gap-2" style={{contain: 'size layout'}}>
      {[...Array(5)].map((_, i) => (
        <div key={i} className="h-4 bg-gray-200 rounded w-16"></div>
      ))}
    </div>
  </div>
);

// Use Next.js dynamic imports with better loading experience
const PieChart = dynamic(
  () => import('react-chartjs-2').then((mod) => mod.Pie),
  { ssr: false, loading: () => <ChartPlaceholder /> }
);

// Import Chart.js components dynamically
const importChartJs = async () => {
  if (typeof window !== 'undefined') {
    const ChartJS = await import('chart.js');
    const { ArcElement, Tooltip, Legend, Chart } = ChartJS;
    Chart.register(ArcElement, Tooltip, Legend);
    return true;
  }
  return false;
};

// Chart.js registration will be done in useEffect

// Chart.js registration will happen in the lazy-loaded component

interface ExpenseCategoryChartProps {
  userId: string;
}

// Memoized empty state component
const EmptyState = memo(() => (
  <div className="py-8 text-center" style={{height: '350px', contain: 'size layout'}}>
    <div className="h-16 w-16 mx-auto mb-4 rounded-full bg-blue-100 flex items-center justify-center" style={{aspectRatio: '1/1'}}>
      <svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8 text-blue-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 13h6m-3-3v6m-9 1V7a2 2 0 012-2h6l2 2h6a2 2 0 012 2v8a2 2 0 01-2 2H5a2 2 0 01-2-2z" />
      </svg>
    </div>
    <p className="text-sm text-blueGray-600">No expense data available</p>
  </div>
));
EmptyState.displayName = 'EmptyState';

// Memoized timeframe selector component
const TimeframeSelector = memo(({ timeframe, setTimeframe }: { timeframe: 'month' | 'year', setTimeframe: (t: 'month' | 'year') => void }) => (
  <div className="flex space-x-2">
    <button
      onClick={() => setTimeframe('month')}
      className={`px-3 py-1 text-xs rounded-full ${
        timeframe === 'month'
          ? 'bg-blue-500 text-white'
          : 'bg-blueGray-200 text-blueGray-700 hover:bg-blueGray-300'
      } transition-colors duration-200`}
    >
      Month
    </button>
    <button
      onClick={() => setTimeframe('year')}
      className={`px-3 py-1 text-xs rounded-full ${
        timeframe === 'year'
          ? 'bg-blue-500 text-white'
          : 'bg-blueGray-200 text-blueGray-700 hover:bg-blueGray-300'
      } transition-colors duration-200`}
    >
      Year
    </button>
  </div>
));
TimeframeSelector.displayName = 'TimeframeSelector';

export default function ExpenseCategoryChart({ userId }: ExpenseCategoryChartProps) {
  const [timeframe, setTimeframe] = useState<'month' | 'year'>('month');
  // State for tracking if component is mounted (for deferred loading)
  const [isMounted, setIsMounted] = useState(false);
  // State to track if Chart.js is initialized
  const [chartInitialized, setChartInitialized] = useState(false);
  
  const transactionRepository = new ApiTransactionRepository();
  const categoryRepository = new ApiCategoryRepository();
  
  // Initialize Chart.js
  useEffect(() => {
    importChartJs().then(initialized => {
      setChartInitialized(initialized);
      console.log('Chart.js initialized:', initialized);
    });
  }, []);
  
  // Use effect to defer non-critical data loading
  useEffect(() => {
    // Set mounted immediately to start loading data faster
    setIsMounted(true);
    console.log('Component mounted, setting isMounted to true');
    
    // Debug the userId to ensure it's available
    console.log('Current userId:', userId);
    
    return () => {
      setIsMounted(false);
    };
  }, [userId]);
  
  // Get all transactions for the user with deferred loading
  const { data: transactions, isLoading: isLoadingTransactions, error: transactionsError } = useQuery({
    queryKey: ['transactions', userId],
    queryFn: () => transactionRepository.findByUserId(userId),
    enabled: !!userId && isMounted,
    staleTime: 30 * 1000, // 30 seconds
    retry: 2, // Retry failed requests
    refetchOnWindowFocus: false // Prevent unnecessary refetches
  });

  // Direct fetch for category data with timeframe filter - similar to MonthlyTrendsChart approach
  const { data: categoryChartData, isLoading: isLoadingCategoryData, refetch: refetchCategoryData } = useQuery({
    queryKey: ['categoryChartData', userId, timeframe],
    queryFn: async () => {
      console.log('Fetching category chart data directly...');
      console.log('Using userId:', userId);
      try {
        // Fetch transactions
        const transactions = await transactionRepository.findByUserId(userId);
        console.log('Transactions fetched:', transactions ? transactions.length : 0);
        // Fetch categories
        const categories = await categoryRepository.findAll();
        console.log('Categories fetched:', categories ? categories.length : 0);
        
        if (!transactions || !categories) {
          console.log('No transactions or categories available');
          return null;
        }
        
        // Filter transactions by timeframe and type (expenses only)
        const now = new Date();
        // Removed unused monthCount variable
        const startDate = new Date(now);
        // Set start date to beginning of current month (for 'month') or beginning of year (for 'year')
        if (timeframe === 'month') {
          startDate.setDate(1); // First day of current month
          startDate.setHours(0, 0, 0, 0); // Beginning of the day
        } else {
          // For year timeframe
          startDate.setMonth(now.getMonth() - 11); // Go back 11 months (12 months total including current)
          startDate.setDate(1); // First day of that month
          startDate.setHours(0, 0, 0, 0); // Beginning of the day
        }
        
        // Set end date to current date at end of day
        const endDate = new Date(now);
        endDate.setHours(23, 59, 59, 999); // End of the day
        
        console.log('Filtering transactions by timeframe:', { 
          timeframe, 
          startDate: startDate.toISOString(), 
          endDate: endDate.toISOString() 
        });
        
        const filteredTransactions = transactions.filter((t) => {
          const transactionDate = new Date(t.date);
          const isExpense = t.type === TransactionType.EXPENSE;
          const isInTimeframe = transactionDate >= startDate && transactionDate <= endDate;
          
          // Debug each transaction's date comparison
          if (isExpense && !isInTimeframe) {
            console.log(`Transaction ${t.id} excluded: date=${transactionDate.toISOString()}, outside range ${startDate.toISOString()} to ${endDate.toISOString()}`);
          }
          
          return isExpense && isInTimeframe;
        });
        
        // Group by category and calculate totals
        const categoryTotals: Record<string, number> = {};
        
        // Debug transactions
        console.log('Filtered transactions:', filteredTransactions.length);
        console.log('Sample transaction:', filteredTransactions.length > 0 ? filteredTransactions[0] : 'No transactions');
        
        // Add more detailed debugging for transaction dates
        if (filteredTransactions.length === 0 && transactions.length > 0) {
          console.log('Transaction date analysis:');
          transactions.slice(0, 3).forEach((t, index) => {
            const transactionDate = new Date(t.date);
            console.log(`Transaction ${index} (${t.id}):`); 
            console.log(`- Date: ${transactionDate.toISOString()}`);
            console.log(`- Type: ${t.type}`);
            console.log(`- Is Expense: ${t.type === TransactionType.EXPENSE}`);
            console.log(`- In timeframe: ${transactionDate >= startDate && transactionDate <= endDate}`);
            console.log(`- Compare with startDate: ${transactionDate >= startDate ? 'after/equal' : 'before'} ${startDate.toISOString()}`);
            console.log(`- Compare with endDate: ${transactionDate <= endDate ? 'before/equal' : 'after'} ${endDate.toISOString()}`);
          });
        }
        
        filteredTransactions.forEach(transaction => {
          // After refactoring, we should primarily use categoryId
          let categoryId = transaction.categoryId;
          
          // Debug the transaction categoryId
          console.log(`Transaction ${transaction.id} categoryId:`, categoryId, typeof categoryId);
          
          if (!categoryId) {
            console.log('Transaction missing categoryId:', transaction);
            // Try to use category as fallback if available
            if (transaction.category) {
              console.log('Using category as fallback for transaction:', transaction.id);
              categoryId = transaction.category;
              transaction.categoryId = transaction.category;
            } else {
              console.log('Transaction has neither categoryId nor category:', transaction);
              return;
            }
          }
          
          // Normalize categoryId to string if it's an object with toString method
          if (typeof categoryId === 'object' && categoryId !== null) {
            // Check if toString method exists on the object
            if (categoryId && 'toString' in categoryId && typeof (categoryId as { toString(): string }).toString === 'function') {
              categoryId = (categoryId as { toString(): string }).toString();
              console.log(`Normalized categoryId to string: ${categoryId}`);
            } else if (categoryId && typeof categoryId === 'object' && '$oid' in (categoryId as { $oid: string })) {
              // Handle MongoDB ObjectId format
              categoryId = (categoryId as { $oid: string }).$oid;
              console.log(`Extracted MongoDB ObjectId: ${categoryId}`);
            }
          }
          
          // Ensure categoryId is a string
          categoryId = String(categoryId);
          
          // Ensure we have a valid categoryId before using it as an index
          if (categoryId) {
            if (!categoryTotals[categoryId]) {
              categoryTotals[categoryId] = 0;
            }
            
            categoryTotals[categoryId] += transaction.amount;
          }
        });
        
        // Debug categories
        console.log('Categories:', categories.length);
        console.log('Sample category:', categories[0]);
        console.log('Category totals:', categoryTotals);
        
        // Map category IDs to names and colors
        const categoryIds = Object.keys(categoryTotals);
        
        // Log all category IDs and available categories for debugging
        console.log('All category IDs from transactions:', categoryIds);
        console.log('All available categories:', categories.map(c => {
          // Log each category's ID formats for debugging
          const idFormats = {
            id: c.id,
            _id: c._id,
            _idString: c._id ? c._id.toString() : undefined,
            _idOid: c._id && typeof c._id === 'object' && '$oid' in (c._id as { $oid: string }) ? (c._id as { $oid: string }).$oid : undefined,
            name: c.name
          };
          console.log(`Category ${c.name} ID formats:`, idFormats);
          return idFormats;
        }));
        
        // Ensure we have valid category IDs
        if (categoryIds.length === 0) {
          console.log('No category IDs found in transactions');
          return null;
        }
        
        const labels = categoryIds.map(id => {
          if (!id) {
            console.log('Invalid category ID found:', id);
            return 'Unknown Category';
          }
          
          // Try all possible matching approaches
          let category = null;
          
          // Try direct ID matching first
          category = categories.find(c => c.id === id);
          if (category) console.log(`Found category by id match: ${category.name}`);
          
          // Try _id direct match
          if (!category) {
            category = categories.find(c => c._id === id);
            if (category) console.log(`Found category by _id match: ${category.name}`);
          }
          
          // Try string comparison of _id
          if (!category) {
            category = categories.find(c => c._id && c._id.toString && c._id.toString() === id);
            if (category) console.log(`Found category by _id.toString() match: ${category.name}`);
          }
          
          // Try MongoDB ObjectId format
          if (!category) {
            category = categories.find(c => c._id && typeof c._id === 'object' && '$oid' in (c._id as { $oid: string }) && (c._id as { $oid: string }).$oid === id);
          }
          
          // Try case-insensitive matching
          if (!category) {
            category = categories.find(c => 
              (c.id && c.id.toLowerCase() === id.toLowerCase()) || 
              (c._id && c._id.toString && c._id.toString().toLowerCase() === id.toLowerCase())
            );
            if (category) console.log(`Found category by case-insensitive match: ${category.name}`);
          }
          
          // Try partial matching as last resort
          if (!category) {
            category = categories.find(c => 
              (c.id && id.includes(c.id)) || 
              (c.id && c.id.includes(id)) ||
              (c._id && c._id.toString && (id.includes(c._id.toString()) || c._id.toString().includes(id)))
            );
            if (category) console.log(`Found category by partial match: ${category.name}`);
          }
          
          if (!category) {
            console.log(`Category not found for ID: ${id}`);
          } else {
            console.log(`Category found for ID ${id}:`, category.name);
          }
          
          return category?.name || `Unknown (${id})`;
        });
        
        const data = categoryIds.map(id => categoryTotals[id]);
        
        // Get colors from category data if available, otherwise use defaults
        const backgroundColors = categoryIds.map(id => {
          // Try all possible matching approaches (same as above for consistency)
          let category = null;
          
          // Try direct ID matching first
          category = categories.find(c => c.id === id);
          
          // Try _id direct match
          if (!category) {
            category = categories.find(c => c._id === id);
          }
          
          // Try string comparison of _id
          if (!category) {
            category = categories.find(c => c._id && c._id.toString && c._id.toString() === id);
          }
          
          // Try MongoDB ObjectId format
          if (!category) {
            category = categories.find(c => c._id && typeof c._id === 'object' && '$oid' in (c._id as { $oid: string }) && (c._id as { $oid: string }).$oid === id);
          }
          
          // Try case-insensitive matching
          if (!category) {
            category = categories.find(c => 
              (c.id && c.id.toLowerCase() === id.toLowerCase()) || 
              (c._id && c._id.toString && c._id.toString().toLowerCase() === id.toLowerCase())
            );
          }
          
          // Try partial matching as last resort
          if (!category) {
            category = categories.find(c => 
              (c.id && id.includes(c.id)) || 
              (c.id && c.id.includes(id)) ||
              (c._id && c._id.toString && (id.includes(c._id.toString()) || c._id.toString().includes(id)))
            );
          }
          
          const color = category?.color || getRandomColor(id);
          console.log(`Color for category ${id}:`, color);
          return color;
        });
        
        const chartData = {
          labels,
          datasets: [
            {
              label: 'Expenses by Category',
              data,
              backgroundColor: backgroundColors,
              borderColor: backgroundColors.map(color => adjustColor(color, -20)),
              borderWidth: 1,
            },
          ],
        };
        
        console.log('Chart data fetched successfully:', chartData);
        return chartData;
      } catch (error) {
        console.error('Error fetching category chart data:', error);
        return null;
      }
    },
    enabled: !!userId && isMounted && chartInitialized,
    staleTime: 30 * 1000, // 30 seconds
    retry: 2
  });

  // Log any errors
  useEffect(() => {
    if (transactionsError) {
      console.error('Transaction query error:', transactionsError);
      // Try to extract more detailed error information
      const errorDetails = transactionsError instanceof Error ? transactionsError.message : 'Unknown error';
      console.error('Transaction error details:', errorDetails);
    }
  }, [transactionsError]);

  // Make sure we consider all loading states
  const isLoading = isLoadingTransactions || isLoadingCategoryData || !isMounted || !chartInitialized;
  
  // Debug when loading state changes
  useEffect(() => {
    if (!isLoading && categoryChartData === null) {
      console.log('Loading finished but chart data is still null. Checking conditions:');
      console.log('- userId available:', !!userId);
      console.log('- isMounted:', isMounted);
      console.log('- chartInitialized:', chartInitialized);
      console.log('- transactions available:', !!transactions && transactions.length > 0);
    }
  }, [isLoading, categoryChartData, userId, isMounted, chartInitialized, transactions]);
  
  // Debug loading states
  useEffect(() => {
    console.log('Loading states:', { 
      chartInitialized,
      isLoading,
      isLoadingCategoryData,
      isLoadingTransactions,
      isMounted 
    });
    
    // If all conditions are met but we still don't have data, manually trigger a refetch
    if (isMounted && chartInitialized && !isLoadingCategoryData && !categoryChartData && userId) {
      console.log('All conditions met but no data, triggering manual refetch');
      refetchCategoryData();
    }
  }, [isLoadingTransactions, isLoadingCategoryData, isMounted, chartInitialized, isLoading, categoryChartData, userId, refetchCategoryData]);

  // Helper function to generate consistent random colors based on string
  const getRandomColor = (str: string) => {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      hash = str.charCodeAt(i) + ((hash << 5) - hash);
    }
    let color = '#';
    for (let i = 0; i < 3; i++) {
      const value = (hash >> (i * 8)) & 0xFF;
      color += ('00' + value.toString(16)).substr(-2);
    }
    return color;
  };

  // Helper function to adjust color brightness
  const adjustColor = (color: string, amount: number) => {
    return '#' + color.replace(/^#/, '').replace(/../g, color => {
      const num = Math.min(255, Math.max(0, parseInt(color, 16) + amount));
      return ('0' + num.toString(16)).substr(-2);
    });
  };

  // Chart options - defined outside the render to prevent recreation
  const chartOptions = {
    responsive: true,
    maintainAspectRatio: false,
    plugins: {
      legend: {
        position: 'right' as const,
        labels: {
          boxWidth: 12,
          padding: 15,
          font: {
            size: 11,
            family: "'Open Sans', sans-serif"
          },
          color: '#8898aa'
        }
      },
      tooltip: {
        backgroundColor: '#fff',
        titleColor: '#8898aa',
        bodyColor: '#525f7f',
        borderColor: '#e9ecef',
        borderWidth: 1,
        callbacks: {
          label: function(tooltipItem: TooltipItem<'pie'>) {
            const label = tooltipItem.label || '';
            const value = tooltipItem.parsed;
            const total = tooltipItem.dataset.data.reduce((a: number, b: number) => a + b, 0);
            const percentage = Math.round((value / total) * 100);
            return `${label}: $${value.toFixed(2)} (${percentage}%)`;
          }
        }
      }
    }
  };

  interface ChartProps {
    data: {
      labels: string[];
      datasets: Array<{
        label: string;
        data: number[];
        backgroundColor: string[];
        borderColor: string[];
        borderWidth: number;
      }>;
    };
    options: typeof chartOptions;
  }

  // Memoize the chart component to prevent unnecessary re-renders and ensure consistent dimensions
  const Chart = memo(({ data, options }: ChartProps) => (
    <div className="relative h-[350px] w-full" style={{contain: 'size layout', aspectRatio: '1/1'}}>
      <Suspense fallback={<ChartPlaceholder />}>
        <PieChart data={data} options={options} />
      </Suspense>
    </div>
  ));
  Chart.displayName = 'Chart';

  // Add enhanced debugging for chart data and component state
  useEffect(() => {
    if (categoryChartData) {
      console.log('Chart data ready:', categoryChartData);
      console.log('Chart data length:', categoryChartData.datasets[0].data.length);
      console.log('Chart labels:', categoryChartData.labels);
    } else {
      console.log('Chart data is null');
      // Log component state to help diagnose the issue
      console.log('Component state:', {
        userId,
        timeframe,
        isMounted,
        chartInitialized,
        isLoadingTransactions,
        isLoadingCategoryData,
        transactionsAvailable: !!transactions && transactions.length > 0
      });
      
      // Check if userId is valid
      if (!userId) {
        console.error('UserId is missing or invalid:', userId);
      }
      
      // Check if API endpoints are correctly configured
      console.log('API endpoints:', {
        transactions: `${process.env.NEXT_PUBLIC_API_URL || 'http://localhost:5000'}/transactions?userId=${userId}`,
        categories: `${process.env.NEXT_PUBLIC_API_URL || 'http://localhost:5000'}/categories`
      });
    }
  }, [categoryChartData, userId, timeframe, isMounted, chartInitialized, isLoadingTransactions, isLoadingCategoryData, transactions]);

  // Render a static placeholder first to improve LCP
  // Then replace with dynamic content when data is loaded
  if (isLoading || !categoryChartData) {
    console.log('Rendering skeleton, loading state:', { isLoading, hasCategoryChartData: !!categoryChartData });
    return <ChartSkeleton />;
  }

  return (
    <div style={{contain: 'content', height: '400px'}}>
      <div className="flex items-center justify-between mb-4" style={{height: '30px', contain: 'size layout'}}>
        <TimeframeSelector timeframe={timeframe} setTimeframe={setTimeframe} />
      </div>

      {/* Show a static placeholder during initial load to improve LCP */}
      <div style={{height: '350px', contain: 'size layout'}}>
        {isLoading ? (
          <ChartPlaceholder />
        ) : categoryChartData && categoryChartData.datasets[0].data.length > 0 ? (
          <Chart data={categoryChartData} options={chartOptions} />
        ) : (
          <div>
            <EmptyState />
            <div className="text-xs text-center mt-2 text-gray-500">
              {isLoadingCategoryData ? 'Loading categories...' : 
               isLoadingTransactions ? 'Loading transactions...' : 
               transactions && transactions.length === 0 ? 'No transactions found' :
               'No expense data available for the selected timeframe'}
            </div>
          </div>
        )}
      </div>
    </div>
  );
}
