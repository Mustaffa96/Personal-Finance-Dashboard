I’ll guide you through building a Next.js application with NextAuth, React-Query, React-Hook-Form, TypeScript, MongoDB, Fastify, Node.js, and TailwindCSS, following Clean Architecture, Clean Code principles, and optimizing for low-memory usage and application health. The focus will be on the Entity-Repository pattern for data management, with a hands-on, step-by-step approach. I’ll ensure the explanation is concise, practical, and aligned with your stack while emphasizing optimization and maintainability.
This example will build a simple User Management System with CRUD operations, authentication, and a clean, scalable structure. I’ll break it into steps, including code snippets and explanations, ensuring low-memory usage and health monitoring.
Step 1: Project Setup
We’ll initialize a Next.js project with TypeScript, install dependencies, and configure the environment for Clean Architecture.
1.1 Initialize Next.js with TypeScript
bash

npx create-next-app@latest user-management-system --typescript --eslint --tailwind --app
cd user-management-system
Select TailwindCSS during setup for styling.
Choose the App Router for modern Next.js routing.
1.2 Install Dependencies
Install the required packages for the stack:
bash

npm install @tanstack/react-query @tanstack/react-query-devtools react-hook-form next-auth mongodb fastify @fastify/cors zod @hookform/resolvers
npm install -D @types/node @types/react @types/react-dom ts-node typescript
React-Query: For data fetching and state management.
React-Hook-Form: For form handling with low overhead.
NextAuth: For authentication.
MongoDB: For the database.
Fastify: For a lightweight backend API.
Zod: For schema validation.
@hookform
/resolvers: To integrate Zod with React-Hook-Form.
1.3 Directory Structure (Clean Architecture)
Organize the project following Clean Architecture, separating concerns into Entities, Use Cases, Repositories, Controllers, and Adapters. This promotes scalability and testability.

user-management-system/
├── src/
│   ├── adapters/              # Interface adapters (e.g., controllers, API routes)
│   │   ├── controllers/       # Fastify controllers
│   │   ├── interfaces/        # API interfaces (e.g., HTTP, CLI)
│   │   └── repositories/      # Repository implementations
│   ├── domain/                # Business logic
│   │   ├── entities/          # Business entities (e.g., User)
│   │   ├── use-cases/         # Application-specific business rules
│   │   └── interfaces/        # Repository and service interfaces
│   ├── infrastructure/        # External systems (e.g., database, logging)
│   │   ├── database/          # MongoDB connection
│   │   └── logging/           # Logging utilities
│   ├── app/                   # Next.js App Router pages and layouts
│   │   ├── api/               # Next.js API routes (for NextAuth)
│   │   ├── components/        # Reusable UI components
│   │   └── globals.css        # TailwindCSS global styles
│   ├── lib/                   # Shared utilities (e.g., React-Query setup)
│   └── types/                 # TypeScript types
├── fastify/                   # Fastify server for custom backend
│   ├── routes/                # Fastify routes
│   └── server.ts              # Fastify server entry
├── public/                    # Static assets
├── tailwind.config.ts         # TailwindCSS configuration
├── tsconfig.json              # TypeScript configuration
├── next.config.mjs            # Next.js configuration
└── package.json
Entities: Core business objects (e.g., User).
Use Cases: Business rules and application logic.
Repositories: Data access interfaces and implementations.
Adapters: Connect use cases to external systems (e.g., Fastify controllers, MongoDB).
Infrastructure: External services like databases or logging.
App: Next.js frontend with TailwindCSS-styled components.
1.4 Configure TypeScript
Update tsconfig.json for strict typing and low-memory usage:
json

{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "baseUrl": "src",
    "paths": {
      "@/*": ["*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
  "exclude": ["node_modules"]
}
incremental: Enables incremental compilation for faster builds.
strict: Enforces type safety for cleaner code.
paths: Simplifies imports with aliases (e.g., @/domain/entities/User).
1.5 Optimize Next.js Configuration
Edit next.config.mjs for performance:
javascript

/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true, // Catch issues early
  swcMinify: true, // Use SWC for faster minification
  experimental: {
    optimizePackageImports: ["@tanstack/react-query"], // Optimize imports
  },
  images: {
    domains: [], // Add domains if using external images
  },
};

export default nextConfig;
swcMinify: Reduces bundle size and memory usage.
reactStrictMode: Ensures components are pure and optimized.
Step 2: Domain Layer (Entities and Use Cases)
The domain layer contains the core business logic, independent of frameworks or databases. We’ll define the User entity and use cases for CRUD operations.
2.1 Define the User Entity
Create src/domain/entities/User.ts:
typescript

import { z } from 'zod';

// Zod schema for validation
export const UserSchema = z.object({
  id: z.string().optional(), // MongoDB generates _id
  name: z.string().min(2, 'Name must be at least 2 characters'),
  email: z.string().email('Invalid email address'),
  password: z.string().min(6, 'Password must be at least 6 characters').optional(), // Optional for external auth
  createdAt: z.date().optional(),
});

// TypeScript type inferred from Zod schema
export type User = z.infer<typeof UserSchema>;

// Entity class for business logic
export class UserEntity {
  private constructor(private props: User) {}

  static create(props: Omit<User, 'id' | 'createdAt'>): UserEntity {
    const validatedProps = UserSchema.parse({
      ...props,
      createdAt: new Date(),
    });
    return new UserEntity(validatedProps);
  }

  get id(): string | undefined {
    return this.props.id;
  }

  get name(): string {
    return this.props.name;
  }

  get email(): string {
    return this.props.email;
  }

  get password(): string | undefined {
    return this.props.password;
  }

  get createdAt(): Date | undefined {
    return this.props.createdAt;
  }

  toJSON(): User {
    return this.props;
  }
}
Zod: Validates user data and infers TypeScript types.
UserEntity: Encapsulates business rules (e.g., validation) and provides a clean interface.
Clean Code: Immutable properties, clear method names, and single responsibility.
2.2 Define Repository Interface
Create src/domain/interfaces/IUserRepository.ts:
typescript

import { User } from '@/domain/entities/User';

export interface IUserRepository {
  create(user: User): Promise<User>;
  findById(id: string): Promise<User | null>;
  findByEmail(email: string): Promise<User | null>;
  update(id: string, user: Partial<User>): Promise<User | null>;
  delete(id: string): Promise<boolean>;
}
Defines the contract for data access, keeping the domain layer independent of infrastructure.
Promotes testability by allowing mock implementations.
2.3 Define Use Cases
Create src/domain/use-cases/CreateUserUseCase.ts:
typescript

import { User, UserEntity } from '@/domain/entities/User';
import { IUserRepository } from '@/domain/interfaces/IUserRepository';

export class CreateUserUseCase {
  constructor(private userRepository: IUserRepository) {}

  async execute(input: Omit<User, 'id' | 'createdAt'>): Promise<User> {
    const userEntity = UserEntity.create(input);
    return this.userRepository.create(userEntity.toJSON());
  }
}
Similarly, create use cases for GetUserById, UpdateUser, DeleteUser, and GetUserByEmail. Example for GetUserById:
typescript

import { User } from '@/domain/entities/User';
import { IUserRepository } from '@/domain/interfaces/IUserRepository';

export class GetUserByIdUseCase {
  constructor(private userRepository: IUserRepository) {}

  async execute(id: string): Promise<User | null> {
    return this.userRepository.findById(id);
  }
}
Use Cases: Orchestrate business logic, keeping it separate from controllers and repositories.
Dependency Injection: Repositories are injected, making the code testable and flexible.
Clean Code: Single responsibility, clear input/output types.
Step 3: Infrastructure Layer (MongoDB and Fastify)
The infrastructure layer connects the domain to external systems like MongoDB and Fastify.
3.1 Set Up MongoDB
Create src/infrastructure/database/mongodb.ts:
typescript

import { MongoClient, Db } from 'mongodb';

let client: MongoClient | null = null;
let db: Db | null = null;

export async function connectToDatabase(): Promise<Db> {
  if (db) return db;

  const uri = process.env.MONGODB_URI || 'mongodb://localhost:27017';
  const dbName = process.env.MONGODB_DB || 'user_management';

  try {
    client = new MongoClient(uri, {
      maxPoolSize: 10, // Limit connections for low memory
      minPoolSize: 2,
      connectTimeoutMS: 5000,
    });
    await client.connect();
    db = client.db(dbName);
    console.log('Connected to MongoDB');
    return db;
  } catch (error) {
    console.error('MongoDB connection error:', error);
    throw error;
  }
}

export async function closeDatabaseConnection(): Promise<void> {
  if (client) {
    await client.close();
    client = null;
    db = null;
    console.log('MongoDB connection closed');
  }
}
Connection Pooling: Limits connections (maxPoolSize) to reduce memory usage.
Singleton Pattern: Reuses the database connection to avoid overhead.
Error Handling: Logs errors for health monitoring.
Add environment variables in .env.local:

MONGODB_URI=mongodb://localhost:27017
MONGODB_DB=user_management
3.2 Implement User Repository
Create src/adapters/repositories/MongoUserRepository.ts:
typescript

import { Db, ObjectId } from 'mongodb';
import { User } from '@/domain/entities/User';
import { IUserRepository } from '@/domain/interfaces/IUserRepository';

export class MongoUserRepository implements IUserRepository {
  private collectionName = 'users';

  constructor(private db: Db) {}

  async create(user: User): Promise<User> {
    const result = await this.db.collection(this.collectionName).insertOne(user);
    return { ...user, id: result.insertedId.toString() };
  }

  async findById(id: string): Promise<User | null> {
    const user = await this.db
      .collection(this.collectionName)
      .findOne({ _id: new ObjectId(id) });
    if (!user) return null;
    return { ...user, id: user._id.toString() };
  }

  async findByEmail(email: string): Promise<User | null> {
    const user = await this.db.collection(this.collectionName).findOne({ email });
    if (!user) return null;
    return { ...user, id: user._id.toString() };
  }

  async update(id: string, user: Partial<User>): Promise<User | null> {
    const result = await this.db
      .collection(this.collectionName)
      .findOneAndUpdate(
        { _id: new ObjectId(id) },
        { $set: user },
        { returnDocument: 'after' }
      );
    if (!result.value) return null;
    return { ...result.value, id: result.value._id.toString() };
  }

  async delete(id: string): Promise<boolean> {
    const result = await this.db
      .collection(this.collectionName)
      .deleteOne({ _id: new ObjectId(id) });
    return result.deletedCount > 0;
  }
}
Entity-Repository Pattern: Maps domain entities to MongoDB documents.
Type Safety: Uses TypeScript to ensure correct data shapes.
Low-Memory: Avoids loading unnecessary data by using projections where possible.
3.3 Set Up Fastify Server
Create fastify/server.ts:
typescript

import Fastify from 'fastify';
import cors from '@fastify/cors';
import { connectToDatabase } from '@/infrastructure/database/mongodb';
import userRoutes from './routes/userRoutes';

const fastify = Fastify({ logger: true });

fastify.register(cors, {
  origin: process.env.NEXT_PUBLIC_URL || 'http://localhost:3000',
});

fastify.register(async (instance) => {
  const db = await connectToDatabase();
  instance.decorate('db', db);
  instance.register(userRoutes, { prefix: '/api/users' });
});

const start = async () => {
  try {
    await fastify.listen({ port: 4000 });
    console.log('Fastify server running on http://localhost:4000');
  } catch (err) {
    fastify.log.error(err);
    process.exit(1);
  }
};

start();
Fastify: Lightweight and faster than Express, reducing memory usage.
CORS: Allows Next.js frontend to communicate with the backend.
Database Injection: Makes the MongoDB connection available to routes.
Create fastify/routes/userRoutes.ts:
typescript

import { FastifyPluginAsync } from 'fastify';
import { MongoUserRepository } from '@/adapters/repositories/MongoUserRepository';
import { CreateUserUseCase } from '@/domain/use-cases/CreateUserUseCase';
import { GetUserByIdUseCase } from '@/domain/use-cases/GetUserByIdUseCase';
import { UserSchema } from '@/domain/entities/User';
import { z } from 'zod';

const userRoutes: FastifyPluginAsync = async (fastify) => {
  const userRepository = new MongoUserRepository(fastify.db);
  
  fastify.post<{ Body: Omit<z.infer<typeof UserSchema>, 'id' | 'createdAt'> }>(
    '/',
    async (request, reply) => {
      const createUserUseCase = new CreateUserUseCase(userRepository);
      const user = await createUserUseCase.execute(request.body);
      return reply.status(201).send(user);
    }
  );

  fastify.get<{ Params: { id: string } }>('/:id', async (request, reply) => {
    const getUserByIdUseCase = new GetUserByIdUseCase(userRepository);
    const user = await getUserByIdUseCase.execute(request.params.id);
    if (!user) {
      return reply.status(404).send({ error: 'User not found' });
    }
    return reply.send(user);
  });
};

export default userRoutes;
Controllers: Map HTTP requests to use cases.
Zod Validation: Ensures incoming data matches the schema.
Clean Architecture: Controllers are adapters, keeping business logic in use cases.
Run the Fastify server:
bash

npx ts-node fastify/server.ts
Step 4: Adapters Layer (Next.js Frontend)
The adapters layer connects the domain to the Next.js frontend, using React-Query, React-Hook-Form, and NextAuth.
4.1 Set Up React-Query
Create src/lib/queryClient.ts:
typescript

import { QueryClient } from '@tanstack/react-query';

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 1, // Limit retries to reduce network overhead
      staleTime: 5 * 60 * 1000, // Cache data for 5 minutes
      gcTime: 10 * 60 * 1000, // Garbage collect after 10 minutes
    },
  },
});
Wrap the app with the QueryClient provider in src/app/layout.tsx:
typescript

'use client';

import { QueryClientProvider } from '@tanstack/react-query';
import { queryClient } from '@/lib/queryClient';
import './globals.css';

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>
        <QueryClientProvider client={queryClient}>
          {children}
        </QueryClientProvider>
      </body>
    </html>
  );
}
React-Query: Manages server state efficiently.
Optimization: Caching and garbage collection reduce memory usage and API calls.
4.2 Set Up NextAuth
Create src/app/api/auth/[...nextauth]/route.ts:
typescript

import NextAuth from 'next-auth';
import CredentialsProvider from 'next-auth/providers/credentials';
import { MongoUserRepository } from '@/adapters/repositories/MongoUserRepository';
import { connectToDatabase } from '@/infrastructure/database/mongodb';
import { GetUserByEmailUseCase } from '@/domain/use-cases/GetUserByEmailUseCase';
import bcrypt from 'bcryptjs';

export const authOptions = {
  providers: [
    CredentialsProvider({
      name: 'Credentials',
      credentials: {
        email: { label: 'Email', type: 'text' },
        password: { label: 'Password', type: 'password' },
      },
      async authorize(credentials) {
        if (!credentials?.email || !credentials?.password) return null;

        const db = await connectToDatabase();
        const userRepository = new MongoUserRepository(db);
        const getUserByEmailUseCase = new GetUserByEmailUseCase(userRepository);
        const user = await getUserByEmailUseCase.execute(credentials.email);

        if (!user || !user.password) return null;

        const isValid = await bcrypt.compare(credentials.password, user.password);
        if (!isValid) return null;

        return { id: user.id!, email: user.email, name: user.name };
      },
    }),
  ],
  session: {
    strategy: 'jwt',
    maxAge: 30 * 24 * 60 * 60, // 30 days
  },
  pages: {
    signIn: '/login',
  },
};

const handler = NextAuth(authOptions);
export { handler as GET, handler as POST };
NextAuth: Handles authentication with credentials provider.
Bcrypt: Secures password comparison.
MongoDB Integration: Uses the repository to fetch users.
Add environment variables in .env.local:

NEXTAUTH_URL=http://localhost:3000
NEXTAUTH_SECRET=your-secret-key-here
4.3 Create User Form with React-Hook-Form
Create src/app/components/UserForm.tsx:
typescript

'use client';

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { UserSchema, User } from '@/domain/entities/User';
import { useMutation } from '@tanstack/react-query';
import { queryClient } from '@/lib/queryClient';

type FormData = Omit<User, 'id' | 'createdAt'>;

async function createUser(data: FormData): Promise<User> {
  const response = await fetch('http://localhost:4000/api/users', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!response.ok) throw new Error('Failed to create user');
  return response.json();
}

export default function UserForm() {
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<FormData>({
    resolver: zodResolver(UserSchema.omit({ id: true, createdAt: true })),
  });

  const mutation = useMutation({
    mutationFn: createUser,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['users'] });
    },
  });

  const onSubmit = (data: FormData) => {
    mutation.mutate(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-4 max-w-md mx-auto">
      <div>
        <label htmlFor="name" className="block text-sm font-medium">
          Name
        </label>
        <input
          id="name"
          {...register('name')}
          className="mt-1 block w-full border rounded-md p-2"
        />
        {errors.name && <p className="text-red-500 text-sm">{errors.name.message}</p>}
      </div>
      <div>
        <label htmlFor="email" className="block text-sm font-medium">
          Email
        </label>
        <input
          id="email"
          type="email"
          {...register('email')}
          className="mt-1 block w-full border rounded-md p-2"
        />
        {errors.email && <p className="text-red-500 text-sm">{errors.email.message}</p>}
      </div>
      <div>
        <label htmlFor="password" className="block text-sm font-medium">
          Password
        </label>
        <input
          id="password"
          type="password"
          {...register('password')}
          className="mt-1 block w-full border rounded-md p-2"
        />
        {errors.password && <p className="text-red-500 text-sm">{errors.password.message}</p>}
      </div>
      <button
        type="submit"
        disabled={mutation.isPending}
        className="w-full bg-blue-500 text-white p-2 rounded-md hover:bg-blue-600"
      >
        {mutation.isPending ? 'Creating...' : 'Create User'}
      </button>
      {mutation.isError && <p className="text-red-500">{mutation.error.message}</p>}
    </form>
  );
}
React-Hook-Form: Minimizes re-renders for low memory usage.
Zod Resolver: Validates form data against the User schema.
React-Query Mutation: Handles API calls and cache invalidation.
TailwindCSS: Styles the form concisely.
4.4 Display User List
Create src/app/page.tsx:
typescript

'use client';

import { useQuery } from '@tanstack/react-query';
import UserForm from './components/UserForm';
import { User } from '@/domain/entities/User';

async function fetchUsers(): Promise<User[]> {
  const response = await fetch('http://localhost:4000/api/users');
  if (!response.ok) throw new Error('Failed to fetch users');
  return response.json();
}

export default function Home() {
  const { data: users, isLoading, error } = useQuery({
    queryKey: ['users'],
    queryFn: fetchUsers,
  });

  return (
    <div className="container mx-auto p-4">
      <h1 className="text-2xl font-bold mb-4">User Management</h1>
      <UserForm />
      <div className="mt-8">
        <h2 className="text-xl font-semibold">Users</h2>
        {isLoading && <p>Loading...</p>}
        {error && <p className="text-red-500">{error.message}</p>}
        {users && (
          <ul className="mt-4 space-y-2">
            {users.map((user) => (
              <li key={user.id} className="border p-2 rounded-md">
                {user.name} ({user.email})
              </li>
            ))}
          </ul>
        )}
      </div>
    </div>
  );
}
React-Query: Fetches and caches the user list.
TailwindCSS: Responsive and minimal styling.
Optimization: Avoids unnecessary re-renders with React-Query’s caching.
Step 5: Authentication Pages
5.1 Create Login Page
Create src/app/login/page.tsx:
typescript

'use client';

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { signIn } from 'next-auth/react';
import { useRouter } from 'next/navigation';

const LoginSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(6, 'Password must be at least 6 characters'),
});

type LoginFormData = z.infer<typeof LoginSchema>;

export default function Login() {
  const router = useRouter();
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<LoginFormData>({
    resolver: zodResolver(LoginSchema),
  });

  const onSubmit = async (data: LoginFormData) => {
    const result = await signIn('credentials', {
      email: data.email,
      password: data.password,
      redirect: false,
    });

    if (result?.error) {
      alert(result.error);
    } else {
      router.push('/');
    }
  };

  return (
    <div className="container mx-auto p-4 max-w-md">
      <h1 className="text-2xl font-bold mb-4">Login</h1>
      <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
        <div>
          <label htmlFor="email" className="block text-sm font-medium">
            Email
          </label>
          <input
            id="email"
            type="email"
            {...register('email')}
            className="mt-1 block w-full border rounded-md p-2"
          />
          {errors.email && <p className="text-red-500 text-sm">{errors.email.message}</p>}
        </div>
        <div>
          <label htmlFor="password" className="block text-sm font-medium">
            Password
          </label>
          <input
            id="password"
            type="password"
            {...register('password')}
            className="mt-1 block w-full border rounded-md p-2"
          />
          {errors.password && <p className="text-red-500 text-sm">{errors.password.message}</p>}
        </div>
        <button
          type="submit"
          className="w-full bg-blue-500 text-white p-2 rounded-md hover:bg-blue-600"
        >
          Login
        </button>
      </form>
    </div>
  );
}
NextAuth: Handles login with credentials.
React-Hook-Form: Efficient form management.
Zod: Validates login data.
Step 6: Optimizations and Health Monitoring
6.1 Low-Memory Usage
React-Query: Caches data to minimize API calls. Set staleTime and gcTime to balance freshness and memory.
Fastify: Lightweight compared to Express, reducing server memory footprint.
MongoDB: Use connection pooling and limit query projections to fetch only necessary fields.
React-Hook-Form: Avoids unnecessary re-renders by managing form state efficiently.
Next.js: Use dynamic imports for heavy components:
typescript

import dynamic from 'next/dynamic';

const HeavyComponent = dynamic(() => import('./components/HeavyComponent'), {
  ssr: false, // Disable server-side rendering for client-only components
});
6.2 Clean Code Practices
Single Responsibility: Each module (entity, use case, repository) has one job.
Type Safety: TypeScript ensures robust typing, reducing runtime errors.
Naming: Descriptive names (e.g., CreateUserUseCase, MongoUserRepository).
Immutability: Entities are immutable to prevent side effects.
Zod: Centralizes validation logic, reused across backend and frontend.
6.3 Health Monitoring
Add a health check endpoint in fastify/routes/healthRoutes.ts:
typescript

import { FastifyPluginAsync } from 'fastify';
import { connectToDatabase } from '@/infrastructure/database/mongodb';

const healthRoutes: FastifyPluginAsync = async (fastify) => {
  fastify.get('/health', async (request, reply) => {
    try {
      const db = await connectToDatabase();
      await db.command({ ping: 1 });
      return reply.status(200).send({ status: 'healthy', database: 'connected' });
    } catch (error) {
      fastify.log.error(error);
      return reply.status(503).send({ status: 'unhealthy', database: 'disconnected' });
    }
  });
};

export default healthRoutes;
Register in fastify/server.ts:
typescript

fastify.register(healthRoutes, { prefix: '/api' });
Health Endpoint: Monitors server and database status.
Logging: Fastify’s built-in logger tracks errors for debugging.
6.4 Performance Monitoring
Use Next.js Analytics or integrate a lightweight monitoring tool like Prometheus with Fastify:
typescript

import fastifyMetrics from 'fastify-metrics';

fastify.register(fastifyMetrics, { endpoint: '/metrics' });
Expose metrics at http://localhost:4000/metrics for monitoring tools.
Track memory usage, CPU, and request latency.
Step 7: Testing the Application
7.1 Start MongoDB
Ensure MongoDB is running locally or use a cloud service like MongoDB Atlas. For local setup:
bash

docker run -d -p 27017:27017 --name mongodb mongo:latest
7.2 Run Fastify Server
bash

npx ts-node fastify/server.ts
7.3 Run Next.js App
bash

npm run dev
Visit http://localhost:3000 to see the app. Test:
Login at /login.
Create users using the form.
View users in the list.
Check the health endpoint at http://localhost:4000/api/health.
Step 8: Additional Optimizations
8.1 Bundle Size Reduction
Use Next.js Bundle Analyzer to identify large dependencies:
bash

npm install -D @next/bundle-analyzer
Update next.config.mjs:
javascript

import withBundleAnalyzer from '@next/bundle-analyzer';

const nextConfig = {
  // ... existing config
};

export default withBundleAnalyzer({
  enabled: process.env.ANALYZE === 'true',
})(nextConfig);
Run ANALYZE=true npm run build to analyze.
Remove unused TailwindCSS classes by enabling PurgeCSS in tailwind.config.ts:
typescript

module.exports = {
  content: [
    './src/app/**/*.{ts,tsx}',
    './src/components/**/*.{ts,tsx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
};
8.2 Database Indexing
Add indexes to MongoDB for faster queries:
typescript

async function setupIndexes() {
  const db = await connectToDatabase();
  await db.collection('users').createIndex({ email: 1 }, { unique: true });
}
setupIndexes();
Indexes: Improve query performance for findByEmail.
8.3 Error Boundaries
Wrap components with error boundaries in src/app/components/ErrorBoundary.tsx:
typescript

'use client';

import { Component, ReactNode } from 'react';

interface Props {
  children: ReactNode;
  fallback: ReactNode;
}

interface State {
  hasError: boolean;
}

export class ErrorBoundary extends Component<Props, State> {
  state: State = { hasError: false };

  static getDerivedStateFromError(): State {
    return { hasError: true };
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback;
    }
    return this.props.children;
  }
}
Use in src/app/page.tsx:
typescript

import ErrorBoundary from './components/ErrorBoundary';

export default function Home() {
  return (
    <ErrorBoundary fallback={<p>Something went wrong.</p>}>
      {/* Existing content */}
    </ErrorBoundary>
  );
}
Error Boundaries: Prevent app crashes, improving reliability.
Step 9: Summary of Clean Architecture and Optimizations
Clean Architecture:
Entities: UserEntity encapsulates business rules.
Use Cases: CreateUserUseCase, etc., handle application logic.
Repositories: MongoUserRepository abstracts data access.
Controllers/Adapters: Fastify routes and Next.js pages connect to use cases.
Clean Code:
Type-safe with TypeScript and Zod.
Single-responsibility modules.
Descriptive naming and immutability.
Low-Memory Usage:
Fastify’s lightweight runtime.
React-Query’s caching.
MongoDB connection pooling.
React-Hook-Form’s minimal re-renders.
Health:
Health check endpoint.
Fastify logging.
Error boundaries and monitoring.
Optimizations:
Bundle size reduction with Next.js and TailwindCSS.
Database indexing.
Dynamic imports for heavy components.
Step 10: Next Steps
Testing: Add unit tests with Jest and integration tests with Cypress.
Deployment: Deploy Next.js to Vercel and Fastify to a Node.js host (e.g., Render).
Scaling: Implement pagination in the user list for large datasets.
Security: Add rate limiting to Fastify and secure NextAuth with OAuth providers.
This setup provides a robust, scalable, and optimized foundation for your application. Let me know if you need help with specific parts, testing, or deployment!